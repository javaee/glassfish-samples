#
# DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS HEADER.
#
# Copyright (c) 2000-2010 Oracle and/or its affiliates. All rights reserved.
#
# The contents of this file are subject to the terms of either the GNU
# General Public License Version 2 only ("GPL") or the Common Development
# and Distribution License("CDDL") (collectively, the "License").  You
# may not use this file except in compliance with the License.  You can
# obtain a copy of the License at
# https://glassfish.dev.java.net/public/CDDL+GPL_1_1.html
# or packager/legal/LICENSE.txt.  See the License for the specific
# language governing permissions and limitations under the License.
#
# When distributing the software, include this License Header Notice in each
# file and include the License file at packager/legal/LICENSE.txt.
#
# GPL Classpath Exception:
# Oracle designates this particular file as subject to the "Classpath"
# exception as provided by Oracle in the GPL Version 2 section of the License
# file that accompanied this code.
#
# Modifications:
# If applicable, add the following below the License Header, with the fields
# enclosed by brackets [] replaced by your own identifying information:
# "Portions Copyright [year] [name of copyright owner]"
#
# Contributor(s):
# If you wish your version of this file to be governed by only the CDDL or
# only the GPL Version 2, indicate your decision by adding "[Contributor]
# elects to include this software in this distribution under the [CDDL or GPL
# Version 2] license."  If you don't indicate a single choice of license, a
# recipient has the option to distribute your version of this file under
# either the CDDL, the GPL Version 2 or to extend the choice of license to
# its licensees as provided above.  However, if you add GPL Version 2 code
# and therefore, elected the GPL Version 2 license, then the option applies
# only if the new code is made subject to such option by the copyright
# holder.
#

#
# WARNING: this file should not be edited by hand.  Any changes
# made to this file will be lost if MQ is un-installed or upgraded.
#
# If you need to change any of the properties, you should do so
# in the broker instance specific configuration file located in
#  .../instances/<instance name>/props/config.properties
#

# This file contains the default value of all properties used by the broker.
# The properties are grouped into the following categories:
#     Connection Services Settings
#     Message Router Settings
#     Security Settings
#     Logger Settings
#     Persistence Settings
#     Destination Management
#     Transaction Settings
#     Miscellaneous Settings

# Version of this file. Do not change
#####################################
imq.config.version=200


##############################################################
# Connection Services Settings
##############################################################

# General Connection Services
#############################

# List of all services in the system
#   - this list is used by the broker when it
#     returns the list of available service to admin
#     if you add a service, you need to update it
#
imq.service.list=jms,admin,ssljms,httpjms,httpsjms,ssladmin,wsjms,wssjms

# List of active services, started at startup
imq.service.activelist=jms,admin

# The hostname imqbrokerd is running on. By default imqbrokerd figures
# this out by getting the hostname of the system it is running on and
# binding to all interfaces on that host. If you want imqbrokerd to bind
# to a particular address on a multi-homed machine then you may specify
# that hostname using imq.hostname.
#
# By default all broker services will bind to the hostname you specify
# here. If you want a particular service to bind to a different hostname
# you may set the specific hostname property for that service
# (for example see imq.jms.tcp.hostname property below).
# imq.hostname=

# Connection Service Specific Settings
######################################

# maximum connections watched by a single thread on this broker
# on windows, this must be no greater than 64 (because of a JDK
# 1.4.0 limitation).
#
# This value is the number of connections (sockets) that can be "selected"
# (polled) using an nio selector. For example, if your
# monitor_limit is set to 10, if you have 24 threads and are running
# the shared thread pool, 3 seperate threads (and selectors) will
# be needed to monitor those connections, the first two watching
# 10 connections, the final watching 4 connections.
#
# This value should be changed for performance or connection
# limitations.
#
imq.shared.connectionMonitor_limit=512

# Some properties settings below are described in other sections of this file.

# Information about thread pool settings:
# min_threads -> the minimum number of threads in the system, the number 
#                MUST be even.
# max_threads -> the maximum # of threads in the system, the number 
#                MUST be even.
# threadpool_model -> the property to switch between the shared thread pool code
#                     and the threadpool thread pool code 
#
# destroy_timeout -> the time the service will wait to clean up state before
#                    giving up and exiting in seconds (default is 30 seconds)
#
# readtimeout -> determines how long a socket will remain blocked in a
#                read (in seconds). This value (if set) should be 
#                larger than the client ping interval. Setting this to 
#                a very small number may decrease performance (tcp only)
#
# solinger -> sets the linger timeout (how long the socket will remain
#                open after a close (tcp only)
#
# jms connection service
imq.jms.protocoltype=tcp
imq.jms.servicetype=NORMAL
imq.jms.tcp.port=0
imq.jms.tcp.backlog=100
imq.jms.min_threads=10
imq.jms.max_threads=1000
#imq.jms.destroy_timeout=30
#imq.jms.threadpool_model=shared
imq.jms.threadpool_model=dedicated
#imq.jms.tcp.readtimeout=0
#imq.jms.tcp.solinger=0
# The name of the specific hostname to bind to. If this property
# is not set or is null use the value of imq.hostname, or if that
# is not set bind to all interfaces.
#imq.jms.tcp.hostname=

# ssljms connection service
imq.ssljms.protocoltype=tls
imq.ssljms.servicetype=NORMAL
imq.ssljms.tls.port=0
imq.ssljms.tls.backlog=100
imq.ssljms.min_threads=10
imq.ssljms.max_threads=500
imq.ssljms.threadpool_model=dedicated
# The name of the specific hostname to bind to. If this property
# is not set or is null use the value of imq.hostname, or if that
# is not set bind to all interfaces.
#imq.ssljms.tls.hostname=

# configuration for the keystore used by the ssl service
imq.keystore.file.dirpath=${imq.etchome}
imq.keystore.file.name=keystore

# location of the passfile to be used for all passwords
imq.passfile.enabled=false
imq.passfile.dirpath=${imq.etchome}
imq.passfile.name=passfile

# admin connection service
imq.admin.protocoltype=tcp
imq.admin.servicetype=ADMIN
imq.admin.tcp.port=0
imq.admin.tcp.backlog=5
imq.admin.min_threads=4
imq.admin.max_threads=10
imq.admin.threadpool_model=dedicated
#imq.admin.tcp.readtimeout=0
#imq.admin.tcp.solinger=0

# ssladmin connection service
imq.ssladmin.protocoltype=tls
imq.ssladmin.servicetype=ADMIN
imq.ssladmin.tls.port=0
imq.ssladmin.tls.backlog=5
imq.ssladmin.max_threads=10
imq.ssladmin.min_threads=4
imq.ssladmin.threadpool_model=dedicated
# The name of the specific hostname to bind to. If this property
# is not set or is null use the value of imq.hostname, or if that
# is not set bind to all interfaces.
#imq.ssladmin.tls.hostname=

# httpjms connection service
imq.httpjms.protocoltype=http
imq.httpjms.servicetype=NORMAL
imq.httpjms.http.servletHost=localhost
imq.httpjms.http.servletPort=7675
imq.httpjms.http.pullPeriod=-1
imq.httpjms.http.connectionTimeout=300
imq.httpjms.min_threads=10
imq.httpjms.max_threads=500
imq.httpjms.threadpool_model=dedicated

# httpsjms connection service
imq.httpsjms.protocoltype=https
imq.httpsjms.servicetype=NORMAL
imq.httpsjms.https.servletHost=localhost
imq.httpsjms.https.servletPort=7674
imq.httpsjms.https.pullPeriod=-1
imq.httpsjms.https.connectionTimeout=300
imq.httpsjms.min_threads=10
imq.httpsjms.max_threads=500
imq.httpsjms.threadpool_model=dedicated

# wsjms connection service
imq.wsjms.protocoltype=ws
imq.wsjms.ws.port=7670
imq.wsjms.ws.backlog=100
#imq.wsjms.ws.solinger=0
imq.wsjms.min_threads=10
imq.wsjms.max_threads=1000
imq.wsjms.services=mqjms,mqstomp,mqjsonstomp

# wssjms connection service
imq.wssjms.protocoltype=wss
imq.wssjms.wss.port=7671
imq.wssjms.wss.backlog=100
#imq.wssjms.wss.solinger=0
imq.wssjms.min_threads=10
imq.wssjms.max_threads=1000
imq.wssjms.services=mqjms,mqstomp,mqjsonstomp


# Supported Protocols
#####################

# Buffer Size
# Set the per connection input and output buffer sizes in bytes.
# For the output buffer this basically affects per packet buffering, so
# having a value larger than your largest packet size may not improve
# performance much.
# For the input buffer this can affect buffering accross packets as
# well, depending on the situation.
# Set to 0 to turn off buffering.
imq.protocol.tcp.inbufsz=2048
imq.protocol.tcp.outbufsz=2048
imq.protocol.tls.inbufsz=2048
imq.protocol.tls.outbufsz=2048
imq.protocol.http.inbufsz=2048
imq.protocol.http.outbufsz=2048
imq.protocol.https.inbufsz=2048
imq.protocol.https.outbufsz=2048
imq.protocol.ws.inbufsz=2048
imq.protocol.ws.outbufsz=2048
imq.protocol.wss.inbufsz=2048
imq.protocol.wss.outbufsz=2048

# No Delay Flags
# this turns off the Nagle's algorithm for socket (turns on TCPNoDelay)
# Nagles algorithm speeds up performance on low band-width systems
# but lowers performance on most systems.
#
# In most configuration, no delay should be true
# (Nagle's algorithm should be off)
#
# This flag is only applicable on protocols running over tcp
# (this includes the tcp, and tls )
imq.protocol.tcp.nodelay=true
imq.protocol.tls.nodelay=true
imq.protocol.http.nodelay=true
imq.protocol.https.nodelay=true
imq.protocol.ws.nodelay=true
imq.protocol.wss.nodelay=true

# Portmapper Settings
#####################

# Specifies the hostname to bind the the broker's portmapper service to.
# This is the service that runs on imqbrokerd's primary (static) port.
# By default the portmapper binds to all interfaces. A value of '*' also
# means bind to all interfaces.
#imq.portmapper.hostname=*

# Port number
imq.portmapper.port=7676

# Max connection backlog
imq.portmapper.backlog=50

# Read timeout in ms. Portmapper attempts to read a version string from 3.0
# clients. 2.0 client don't send this so we must allow the read to timeout.
# The larger this is the slower 2.0 client will connect. If it is too small
# 3.0 clients may get "connection reset by peer" errors when first connecting
# to the broker.
imq.portmapper.sotimeout=500

#start the port mapper without binding to the specified port
#leave set to true unless a proxy port mapper is being used
imq.portmapper.bind=true

##############################################################
# Message Router Settings
##############################################################

# Memory reclamation period
###########################

# The message expiration timeout value determines how often (in
# seconds) the reaper thread will look at the current expiration 
# value for JMS messages
imq.message.expiration.interval=60

# Message limits: broker
########################

# When these limits are reached, new messages received by broker are rejected
# until the system is below these limits

# Count limit (a value of -1 indicates no limit)
imq.system.max_count=-1

# Size limit (a value of -1 indicates no limit)
# To indicate a value other than bytes, an argument [m, k, b] can be added
#              1m-> 1meg
#              1k -> 1 Kbytes
#              1b -> 1 byte
imq.system.max_size=-1

# Individual message limits
###########################

# This sets a limit on the maximum size of ANY message body (in Kbytes)

# Size limit (a value of -1 indicates no limit)
# To indicate a value other than bytes, an argument [m, k, b] can be added
#              1m-> 1meg
#              1k -> 1 Kbytes
#              1b -> 1 byte
imq.message.max_size=70m


##############################################################
# Persistence Settings
##############################################################

# Type of data store
####################

# Both file-based and JDBC-based persistence is currently supported. File-based
# is the default. To plugged in a database, change the value of this property
# to 'jdbc' and update all appropriate JDBC related properties.
#
# imq.persist.store=<file|jdbc>
#
imq.persist.store=file

# File-based store
##################

# Specify the initial size of the message file for destinations.
# If the value is zero, all messages will be stored in its own files.
# Default: 1m (1 Mbyte)
imq.persist.file.message.vrfile.initial_size=1m

# Specify the block size of the message file.
# Default: 256 bytes
imq.persist.file.message.vrfile.block_size=256

# Specify the maximum size of a message that will be stored in the message
# file. Messages that are bigger than this size will be stored in its
# own files.
# Default: 1m (1 Mbyte)
imq.persist.file.message.max_record_size=1m

# The percentage of files in the pool that are kept in a clean state 
# while the broker is running. Any files left in a dirty state may be 
# cleaned up at shutdown (see message.cleanup property). A high value
# keeps the file pool in a clean state which allows the broker to shutdown
# quickly but slows down the  performance of the file pool. A low value
# improves the speed  of the filepool, but may result in the broker taking
# longer to shutdown if the cleanup property is true.
#
# Default: 60 percent
# We set to 0 to maximize performance
imq.persist.file.message.filepool.cleanratio=0

# Maximum number of files in the file pool for each destination used by the
# file based message store. The larger the pool the faster the broker
# can process large numbers of persistent messages at the expense of disk space.
# If the capacity of the file pool is exceeded, the broker will create
# and delete files as needed to process persistent messages.
# Default: 100 files
imq.persist.file.destination.message.filepool.limit=100

# Controls whether the message store is "cleaned up" when the broker exits.
# If the store is to be "cleaned" then the broker will truncate all
# message files to the appropriate size at exit. For files that contain
# message data this will be the size of the message data. For files that
# contain deleted messages this would be 0. Cleaning the store preserves
# disk space but reduces the performance of the file store and slows broker
# exit.  Leaving the store "dirty" lets the broker exit faster, and provides
# an opportunity for disk blocks to be re-used more efficiently between
# broker restarts.
#
# Default: true
# We set to false to improve performance
imq.persist.file.message.cleanup=false

# Controls whether the message store should use memory-mapped file
# to store the transaction data. We set to true to improve performance
# at the cost of heap memory.
#
# Default: true
imq.persist.file.transaction.memorymappedfile.enabled=true

# Controls whether persistence operations synchronize in-memory state with
# the physical storage device. When this is enabled, data loss due to system
# crash will be eliminated at the cost of performance.
#
# Default: false
imq.persist.file.sync.enabled=false

# Controls whether transaction logging is enabled. When this is enabled,
# persistence operations are durably recorded on disk in the transaction
# log files. When a failure occurs, the log records are used during crash
# recovery processing to restore the data store to a consistent state.
# Transaction logging provides data reliability and incurs lower performance
# cost than file sync, i.e. imq.persist.file.sync.enabled.
#
# Default: false
imq.persist.file.txnLog.enabled=false

# This flag is only applicable if transaction logging is enabled.
# If specified, log non-transacted persistent message to ensure it is
# not lost due to system crash.
#
# Default: false
imq.persist.file.txnLog.nonTransactedMsgSend.enabled=false

# Specify the initial size of the transaction log files.
#
# Default: 10m (10 Mbyte)
imq.persist.file.txnLog.file.size=10m

# JDBC-based store
##################

# Controls whether JDBC persistence store should automatically be created.
#
# Default: true
imq.persist.storecreate.all=true

# An identifier to make database table names unique per broker.
# This identifier will be appended to database tables names to make 
# them unique in the case where more than one broker instance is using
# the same database.
# The specified value should contain alphanumeric characters only.
# The length of the identifier should not exceed the maximum length
# of a table name allowed in the database minus 13.
# (13 is the length of table name reserved for MQ's internal use.)
#
# NOTE: For brokers belonging to a high-availability (HA) cluster, 
#       imq.cluster.clusterid is used instead.
#imq.brokerid=<alphanumeric id>

# To plugged in a database, change the value of this property to the desired
# database vendor and update all appropriate JDBC related properties.
#
# imq.persist.jdbc.dbVendor=<hadb|oracle|postgresql|mysql|derby|db2>
#
#imq.persist.jdbc.dbVendor=<database_vendor>

#
# Beginning of properties to plug in a Sun HADB database
#

# User name used to open database connection. Replace 'username'.
#imq.persist.jdbc.hadb.user=<username>

# Optional property to specify whether the database requires a password.
#imq.persist.jdbc.hadb.needpassword=[true|false]

# Vendor specific JDBC driver.
imq.persist.jdbc.hadb.driver=com.sun.hadb.jdbc.pool.HadbConnectionPoolDataSource

# Vendor specific properties.

# Replace 'server list' with your comma-separated list of servers.
# imq.persist.jdbc.hadb.property.serverList=<server list>

imq.persist.jdbc.hadb.property.loginTimeout=60
imq.persist.jdbc.hadb.property.queryTimeout=60
imq.persist.jdbc.hadb.property.maxStatements=30
imq.persist.jdbc.hadb.property.eliminateRedundantEndTransaction=true
imq.persist.jdbc.hadb.property.cacheDatabaseMetaData=false

# Properties to define the tables used by the broker. Do not modify the schema.

# Version table
imq.persist.jdbc.hadb.table.MQVER41=\
          CREATE TABLE ${name} (\
              STORE_VERSION INTEGER NOT NULL,\
              LOCK_ID VARCHAR(100),\
              PRIMARY KEY(STORE_VERSION))

# Configuration change record table
imq.persist.jdbc.hadb.table.MQCREC41=\
          CREATE TABLE ${name} (\
              RECORD VARBINARY(4096) NOT NULL,\
              CREATED_TS DOUBLE INTEGER NOT NULL,\
              PRIMARY KEY(CREATED_TS))

# Broker table
imq.persist.jdbc.hadb.table.MQBKR41=\
          CREATE TABLE ${name} (\
              ID VARCHAR(100) NOT NULL,\
              URL VARCHAR(100) NOT NULL,\
              VERSION INTEGER NOT NULL,\
              STATE INTEGER NOT NULL,\
              TAKEOVER_BROKER VARCHAR(100),\
              HEARTBEAT_TS DOUBLE INTEGER,\
              PRIMARY KEY(ID))

# Store session table
imq.persist.jdbc.hadb.table.MQSES41=\
          CREATE TABLE ${name} (\
              ID DOUBLE INTEGER NOT NULL,\
              BROKER_ID VARCHAR(100) NOT NULL,\
              IS_CURRENT INTEGER NOT NULL,\
              CREATED_BY VARCHAR(100) NOT NULL,\
              CREATED_TS DOUBLE INTEGER NOT NULL,\
              PRIMARY KEY(ID))

imq.persist.jdbc.hadb.table.MQSES41.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (\
              BROKER_ID)
imq.persist.jdbc.hadb.table.MQSES41.index.IDX2=\
          CREATE INDEX ${index} ON ${name} (\
              BROKER_ID, IS_CURRENT)

# Destination table
imq.persist.jdbc.hadb.table.MQDST41=\
          CREATE TABLE ${name} (\
              ID VARCHAR(100) NOT NULL,\
              DESTINATION VARBINARY(2048) NOT NULL,\
              IS_LOCAL INTEGER NOT NULL,\
              CONNECTION_ID DOUBLE INTEGER,\
              CONNECTED_TS DOUBLE INTEGER,\
              STORE_SESSION_ID DOUBLE INTEGER,\
              CREATED_TS DOUBLE INTEGER NOT NULL,\
              PRIMARY KEY(ID))

imq.persist.jdbc.hadb.table.MQDST41.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (\
              STORE_SESSION_ID)

# Interest (consumer) table
imq.persist.jdbc.hadb.table.MQCON41=\
          CREATE TABLE ${name} (\
              ID DOUBLE INTEGER NOT NULL,\
              CLIENT_ID VARCHAR(1024),\
              DURABLE_NAME VARCHAR(1024),\
              CONSUMER VARBINARY(2048) NOT NULL,\
              CREATED_TS DOUBLE INTEGER NOT NULL,\
              PRIMARY KEY(ID))

# Interest list (consumer state) table
imq.persist.jdbc.hadb.table.MQCONSTATE41=\
          CREATE TABLE ${name} (\
              MESSAGE_ID VARCHAR(100) NOT NULL,\
              CONSUMER_ID DOUBLE INTEGER NOT NULL,\
              STATE INTEGER,\
              TRANSACTION_ID DOUBLE INTEGER,\
              CREATED_TS DOUBLE INTEGER NOT NULL,\
              PRIMARY KEY(MESSAGE_ID, CONSUMER_ID))

imq.persist.jdbc.hadb.table.MQCONSTATE41.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (\
              TRANSACTION_ID)

imq.persist.jdbc.hadb.table.MQCONSTATE41.index.IDX2=\
          CREATE INDEX ${index} ON ${name} (\
              MESSAGE_ID)

# Message table
imq.persist.jdbc.hadb.table.MQMSG41=\
          CREATE TABLE ${name} (\
              ID VARCHAR(100) NOT NULL,\
              MESSAGE BLOB NOT NULL,\
              MESSAGE_SIZE DOUBLE INTEGER,\
              STORE_SESSION_ID DOUBLE INTEGER NOT NULL,\
              DESTINATION_ID VARCHAR(100),\
              TRANSACTION_ID DOUBLE INTEGER,\
              CREATED_TS DOUBLE INTEGER NOT NULL,\
              PRIMARY KEY(ID))

imq.persist.jdbc.hadb.table.MQMSG41.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (\
              STORE_SESSION_ID, DESTINATION_ID)

# Property table
imq.persist.jdbc.hadb.table.MQPROP41=\
          CREATE TABLE ${name} (\
              PROPNAME VARCHAR(100) NOT NULL,\
              PROPVALUE VARBINARY(4096),\
              PRIMARY KEY(PROPNAME))

# Transaction table
imq.persist.jdbc.hadb.table.MQTXN41=\
          CREATE TABLE ${name} (\
              ID DOUBLE INTEGER NOT NULL,\
              TYPE INTEGER NOT NULL,\
              STATE INTEGER,\
              AUTO_ROLLBACK INTEGER NOT NULL,\
              XID VARCHAR(256),\
              TXN_STATE VARBINARY(2048) NOT NULL,\
              TXN_HOME_BROKER VARBINARY(2048),\
              TXN_BROKERS VARBINARY(2048),\
              STORE_SESSION_ID DOUBLE INTEGER NOT NULL,\
              EXPIRED_TS DOUBLE INTEGER NOT NULL,\
              ACCESSED_TS DOUBLE INTEGER NOT NULL,\
              PRIMARY KEY(ID))

imq.persist.jdbc.hadb.table.MQTXN41.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (\
              STORE_SESSION_ID)

# JMS Bridge TM LogRecord table
imq.persist.jdbc.hadb.table.MQTMLRJMSBG41=\
          CREATE TABLE ${name} (\
              XID VARCHAR(256) NOT NULL,\
              LOG_RECORD VARBINARY(2048) NOT NULL,\
              NAME VARCHAR(100) NOT NULL,\
			  BROKER_ID VARCHAR(100) NOT NULL,\
              CREATED_TS DOUBLE INTEGER NOT NULL,\
              UPDATED_TS DOUBLE INTEGER NOT NULL,\
              PRIMARY KEY(XID))
imq.persist.jdbc.hadb.table.MQTMLRJMSBG41.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (BROKER_ID)
imq.persist.jdbc.hadb.table.MQTMLRJMSBG41.index.IDX2=\
          CREATE INDEX ${index} ON ${name} (NAME)

# JMS Bridges table
imq.persist.jdbc.hadb.table.MQJMSBG41=\
          CREATE TABLE ${name} (\
              NAME VARCHAR(100) NOT NULL,\
			  BROKER_ID VARCHAR(100) NOT NULL,\
              CREATED_TS DOUBLE INTEGER NOT NULL,\
              UPDATED_TS DOUBLE INTEGER NOT NULL,\
              PRIMARY KEY(NAME))

# End of properties to plug in a Sun HADB database

#
# Beginning of properties to plug in an Oracle 10g database
#

# User name used to open database connection. Replace username.
#imq.persist.jdbc.oracle.user=<username>

# Optional property to specify whether the database requires a password.
#imq.persist.jdbc.oracle.needpassword=[true|false]

# Vendor specific JDBC driver.
imq.persist.jdbc.oracle.driver=oracle.jdbc.pool.OracleConnectionPoolDataSource

# Vendor specific properties.

# Vendor specific database url to get a database connection.
# Replace hostname, port and sid in imq.persist.jdbc.oracle.property.url.
# imq.persist.jdbc.oracle.property.url=jdbc:oracle:thin:@<hostname>:<port>:<sid>

imq.persist.jdbc.oracle.property.implicitCachingEnabled=true
imq.persist.jdbc.oracle.property.maxStatements=25

# Properties to define the tables used by the broker. Do not modify the schema.

# Version table
imq.persist.jdbc.oracle.table.MQVER41=\
          CREATE TABLE ${name} (\
              STORE_VERSION INTEGER NOT NULL,\
              LOCK_ID VARCHAR2(100),\
              PRIMARY KEY(STORE_VERSION))

# Configuration change record table
imq.persist.jdbc.oracle.table.MQCREC41=\
          CREATE TABLE ${name} (\
              RECORD BLOB NOT NULL,\
              CREATED_TS NUMBER NOT NULL,\
              PRIMARY KEY(CREATED_TS))

# Broker table
imq.persist.jdbc.oracle.table.MQBKR41=\
          CREATE TABLE ${name} (\
              ID VARCHAR2(100) NOT NULL,\
              URL VARCHAR2(100) NOT NULL,\
              VERSION INTEGER NOT NULL,\
              STATE INTEGER NOT NULL,\
              TAKEOVER_BROKER VARCHAR2(100),\
              HEARTBEAT_TS NUMBER,\
              PRIMARY KEY(ID))

# Store session table
imq.persist.jdbc.oracle.table.MQSES41=\
          CREATE TABLE ${name} (\
              ID NUMBER NOT NULL,\
              BROKER_ID VARCHAR2(100) NOT NULL,\
              IS_CURRENT INTEGER NOT NULL,\
              CREATED_BY VARCHAR2(100) NOT NULL,\
              CREATED_TS NUMBER NOT NULL,\
              PRIMARY KEY(ID))

imq.persist.jdbc.oracle.table.MQSES41.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (\
              BROKER_ID)
imq.persist.jdbc.oracle.table.MQSES41.index.IDX2=\
          CREATE INDEX ${index} ON ${name} (\
              BROKER_ID, IS_CURRENT)

# Destination table
imq.persist.jdbc.oracle.table.MQDST41=\
          CREATE TABLE ${name} (\
              ID VARCHAR2(100) NOT NULL,\
              DESTINATION BLOB NOT NULL,\
              IS_LOCAL INTEGER NOT NULL,\
              CONNECTION_ID NUMBER,\
              CONNECTED_TS NUMBER,\
              STORE_SESSION_ID NUMBER,\
              CREATED_TS NUMBER NOT NULL,\
              PRIMARY KEY(ID))

imq.persist.jdbc.oracle.table.MQDST41.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (\
              STORE_SESSION_ID)

# Interest (consumer) table
imq.persist.jdbc.oracle.table.MQCON41=\
          CREATE TABLE ${name} (\
              ID NUMBER NOT NULL,\
              CLIENT_ID VARCHAR2(1024),\
              DURABLE_NAME VARCHAR2(1024),\
              CONSUMER BLOB NOT NULL,\
              CREATED_TS NUMBER NOT NULL,\
              PRIMARY KEY(ID))

# Interest list (consumer state) table
imq.persist.jdbc.oracle.table.MQCONSTATE41=\
          CREATE TABLE ${name} (\
              MESSAGE_ID VARCHAR2(100) NOT NULL,\
              CONSUMER_ID NUMBER NOT NULL,\
              STATE INTEGER,\
              TRANSACTION_ID NUMBER,\
              CREATED_TS NUMBER NOT NULL,\
              PRIMARY KEY(MESSAGE_ID, CONSUMER_ID))

imq.persist.jdbc.oracle.table.MQCONSTATE41.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (\
              TRANSACTION_ID)

imq.persist.jdbc.oracle.table.MQCONSTATE41.index.IDX2=\
          CREATE INDEX ${index} ON ${name} (\
              MESSAGE_ID)

# Message table
imq.persist.jdbc.oracle.table.MQMSG41=\
          CREATE TABLE ${name} (\
              ID VARCHAR2(100) NOT NULL,\
              MESSAGE BLOB NOT NULL,\
              MESSAGE_SIZE NUMBER,\
              STORE_SESSION_ID NUMBER NOT NULL,\
              DESTINATION_ID VARCHAR2(100),\
              TRANSACTION_ID NUMBER,\
              CREATED_TS NUMBER NOT NULL,\
              PRIMARY KEY(ID))

imq.persist.jdbc.oracle.table.MQMSG41.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (\
              STORE_SESSION_ID, DESTINATION_ID)

# Property table
imq.persist.jdbc.oracle.table.MQPROP41=\
          CREATE TABLE ${name} (\
              PROPNAME VARCHAR2(100) NOT NULL,\
              PROPVALUE BLOB,\
              PRIMARY KEY(PROPNAME))

# Transaction table
imq.persist.jdbc.oracle.table.MQTXN41=\
          CREATE TABLE ${name} (\
              ID NUMBER NOT NULL,\
              TYPE INTEGER NOT NULL,\
              STATE INTEGER,\
              AUTO_ROLLBACK INTEGER NOT NULL,\
              XID VARCHAR2(256),\
              TXN_STATE BLOB NOT NULL,\
              TXN_HOME_BROKER BLOB,\
              TXN_BROKERS BLOB,\
              STORE_SESSION_ID NUMBER NOT NULL,\
              EXPIRED_TS NUMBER NOT NULL,\
              ACCESSED_TS NUMBER NOT NULL,\
              PRIMARY KEY(ID))

imq.persist.jdbc.oracle.table.MQTXN41.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (\
              STORE_SESSION_ID)

# JMS Bridge TM LogRecord table
imq.persist.jdbc.oracle.table.MQTMLRJMSBG41=\
          CREATE TABLE ${name} (\
              XID VARCHAR2(256) NOT NULL,\
              LOG_RECORD BLOB NOT NULL,\
              NAME VARCHAR2(100) NOT NULL,\
              BROKER_ID VARCHAR2(100) NOT NULL,\
              CREATED_TS NUMBER NOT NULL,\
              UPDATED_TS NUMBER NOT NULL,\
              PRIMARY KEY(XID))
imq.persist.jdbc.oracle.table.MQTMLRJMSBG41.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (BROKER_ID)
imq.persist.jdbc.oracle.table.MQTMLRJMSBG41.index.IDX2=\
          CREATE INDEX ${index} ON ${name} (NAME)

# JMS Bridges table
imq.persist.jdbc.oracle.table.MQJMSBG41=\
          CREATE TABLE ${name} (\
              NAME VARCHAR2(100) NOT NULL,\
              BROKER_ID VARCHAR2(100) NOT NULL,\
              CREATED_TS NUMBER NOT NULL,\
              UPDATED_TS NUMBER NOT NULL,\
              PRIMARY KEY(NAME))

# End of properties to plug in an Oracle 10g database

#
# Beginning of properties to plug in a PostgreSQL 8.1 database
#

# User name used to open database connection. Replace username.
#imq.persist.jdbc.postgresql.user=<username>

# Optional property to specify whether the database requires a password.
#imq.persist.jdbc.postgresql.needpassword=[true|false]

# Vendor specific JDBC driver.
imq.persist.jdbc.postgresql.driver=org.postgresql.Driver

# Vendor specific properties.

# Vendor specific database url to get a database connection.
# Replace hostname, port and database in imq.persist.jdbc.postgresql.opendburl.
#imq.persist.jdbc.postgresql.opendburl=jdbc:postgresql://<hostname>:<port>/<database>

# Properties to define the tables used by the broker. Do not modify the schema.

# Version table
imq.persist.jdbc.postgresql.table.MQVER41=\
          CREATE TABLE ${name} (\
              STORE_VERSION INTEGER NOT NULL,\
              LOCK_ID VARCHAR(100),\
              PRIMARY KEY(STORE_VERSION))

# Configuration change record table
imq.persist.jdbc.postgresql.table.MQCREC41=\
          CREATE TABLE ${name} (\
              RECORD BYTEA NOT NULL,\
              CREATED_TS BIGINT NOT NULL,\
              PRIMARY KEY(CREATED_TS))

# Broker table
imq.persist.jdbc.postgresql.table.MQBKR41=\
          CREATE TABLE ${name} (\
              ID VARCHAR(100) NOT NULL,\
              URL VARCHAR(100) NOT NULL,\
              VERSION INTEGER NOT NULL,\
              STATE INTEGER NOT NULL,\
              TAKEOVER_BROKER VARCHAR(100),\
              HEARTBEAT_TS BIGINT,\
              PRIMARY KEY(ID))

# Store session table
imq.persist.jdbc.postgresql.table.MQSES41=\
          CREATE TABLE ${name} (\
              ID BIGINT NOT NULL,\
              BROKER_ID VARCHAR(100) NOT NULL,\
              IS_CURRENT INTEGER NOT NULL,\
              CREATED_BY VARCHAR(100) NOT NULL,\
              CREATED_TS BIGINT NOT NULL,\
              PRIMARY KEY(ID))

imq.persist.jdbc.postgresql.table.MQSES41.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (\
              BROKER_ID)
imq.persist.jdbc.postgresql.table.MQSES41.index.IDX2=\
          CREATE INDEX ${index} ON ${name} (\
              BROKER_ID, IS_CURRENT)

# Destination table
imq.persist.jdbc.postgresql.table.MQDST41=\
          CREATE TABLE ${name} (\
              ID VARCHAR(100) NOT NULL,\
              DESTINATION BYTEA NOT NULL,\
              IS_LOCAL INTEGER NOT NULL,\
              CONNECTION_ID BIGINT,\
              CONNECTED_TS BIGINT,\
              STORE_SESSION_ID BIGINT,\
              CREATED_TS BIGINT NOT NULL,\
              PRIMARY KEY(ID))

imq.persist.jdbc.postgresql.table.MQDST41.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (\
              STORE_SESSION_ID)

# Interest (consumer) table
imq.persist.jdbc.postgresql.table.MQCON41=\
          CREATE TABLE ${name} (\
              ID BIGINT NOT NULL,\
              CLIENT_ID VARCHAR(1024),\
              DURABLE_NAME VARCHAR(1024),\
              CONSUMER BYTEA NOT NULL,\
              CREATED_TS BIGINT NOT NULL,\
              PRIMARY KEY(ID))

# Interest list (consumer state) table
imq.persist.jdbc.postgresql.table.MQCONSTATE41=\
          CREATE TABLE ${name} (\
              MESSAGE_ID VARCHAR(100) NOT NULL,\
              CONSUMER_ID BIGINT NOT NULL,\
              STATE INT,\
              TRANSACTION_ID BIGINT,\
              CREATED_TS BIGINT NOT NULL,\
              PRIMARY KEY(MESSAGE_ID, CONSUMER_ID))

imq.persist.jdbc.postgresql.table.MQCONSTATE41.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (\
              TRANSACTION_ID)

imq.persist.jdbc.postgresql.table.MQCONSTATE41.index.IDX2=\
          CREATE INDEX ${index} ON ${name} (\
              MESSAGE_ID)

# Message table
imq.persist.jdbc.postgresql.table.MQMSG41=\
          CREATE TABLE ${name} (\
              ID VARCHAR(100) NOT NULL,\
              MESSAGE BYTEA NOT NULL,\
              MESSAGE_SIZE INTEGER,\
              STORE_SESSION_ID BIGINT NOT NULL,\
              DESTINATION_ID VARCHAR(100),\
              TRANSACTION_ID BIGINT,\
              CREATED_TS BIGINT NOT NULL,\
              PRIMARY KEY(ID))

imq.persist.jdbc.postgresql.table.MQMSG41.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (\
              STORE_SESSION_ID, DESTINATION_ID)

# Property table
imq.persist.jdbc.postgresql.table.MQPROP41=\
          CREATE TABLE ${name} (\
              PROPNAME VARCHAR(100) NOT NULL,\
              PROPVALUE BYTEA,\
              PRIMARY KEY(PROPNAME))

# Transaction table
imq.persist.jdbc.postgresql.table.MQTXN41=\
          CREATE TABLE ${name} (\
              ID BIGINT NOT NULL,\
              TYPE INTEGER NOT NULL,\
              STATE INTEGER,\
              AUTO_ROLLBACK INTEGER NOT NULL,\
              XID VARCHAR(256),\
              TXN_STATE BYTEA NOT NULL,\
              TXN_HOME_BROKER BYTEA,\
              TXN_BROKERS BYTEA,\
              STORE_SESSION_ID BIGINT NOT NULL,\
              EXPIRED_TS BIGINT NOT NULL,\
              ACCESSED_TS BIGINT NOT NULL,\
              PRIMARY KEY(ID))

imq.persist.jdbc.postgresql.table.MQTXN41.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (\
              STORE_SESSION_ID)

# JMS Bridge TM LogRecord table
imq.persist.jdbc.postgresql.table.MQTMLRJMSBG41=\
          CREATE TABLE ${name} (\
              XID VARCHAR(256) NOT NULL,\
              LOG_RECORD BYTEA NOT NULL,\
              NAME VARCHAR(100) NOT NULL,\
              BROKER_ID VARCHAR(100) NOT NULL,\
              CREATED_TS BIGINT NOT NULL,\
              UPDATED_TS BIGINT NOT NULL,\
              PRIMARY KEY(XID))
imq.persist.jdbc.postgresql.table.MQTMLRJMSBG41.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (BROKER_ID)
imq.persist.jdbc.postgresql.table.MQTMLRJMSBG41.index.IDX2=\
          CREATE INDEX ${index} ON ${name} (NAME)

# JMS Bridges table
imq.persist.jdbc.postgresql.table.MQJMSBG41=\
          CREATE TABLE ${name} (\
              NAME VARCHAR(100) NOT NULL,\
              BROKER_ID VARCHAR(100) NOT NULL,\
              CREATED_TS BIGINT NOT NULL,\
              UPDATED_TS BIGINT NOT NULL,\
              PRIMARY KEY(NAME))

# End of properties to plug in a PostgreSQL 8.1 database

#
# Beginning of properties to plug in a MySQL 5.0 database
#

# User name used to open database connection. Replace username.
#imq.persist.jdbc.mysql.user=<username>

# Optional property to specify whether the database requires a password.
#imq.persist.jdbc.mysql.needpassword=[true|false]

# Vendor specific JDBC driver.
imq.persist.jdbc.mysql.driver=com.mysql.jdbc.jdbc2.optional.MysqlConnectionPoolDataSource

# Vendor specific properties.

# Vendor specific database url to get a database connection.
# Replace hostname, port and database in imq.persist.jdbc.oracle.property.url.
#imq.persist.jdbc.mysql.property.url=jdbc:mysql://<hostname>:<port>/<database>

imq.persist.jdbc.mysql.property.cacheResultSetMetadata=true
imq.persist.jdbc.mysql.property.cachePreparedStatements=true
imq.persist.jdbc.mysql.property.preparedStatementCacheSize=25

# The broker will use InnoDB as a default storage engine
# because it can provide transaction-safe tables.
imq.persist.jdbc.mysql.tableoption=ENGINE=InnoDB

# Properties to define the tables used by the broker. Do not modify the schema.

# Version table
imq.persist.jdbc.mysql.table.MQVER41=\
          CREATE TABLE ${name} (\
              STORE_VERSION INT NOT NULL,\
              LOCK_ID VARCHAR(100), \
              PRIMARY KEY(STORE_VERSION)) ${tableoption}

# Configuration change record table
imq.persist.jdbc.mysql.table.MQCREC41=\
          CREATE TABLE ${name} (\
              RECORD VARBINARY(2048) NOT NULL,\
              CREATED_TS BIGINT NOT NULL, \
              PRIMARY KEY(CREATED_TS)) ${tableoption}

# Broker table
imq.persist.jdbc.mysql.table.MQBKR41=\
          CREATE TABLE ${name} (\
              ID VARCHAR(100) NOT NULL,\
              URL VARCHAR(100) NOT NULL,\
              VERSION INT NOT NULL,\
              STATE INT NOT NULL,\
              TAKEOVER_BROKER VARCHAR(100),\
              HEARTBEAT_TS BIGINT,\
              PRIMARY KEY(ID)) ${tableoption}

# Store session table
imq.persist.jdbc.mysql.table.MQSES41=\
          CREATE TABLE ${name} (\
              ID BIGINT NOT NULL,\
              BROKER_ID VARCHAR(100) NOT NULL,\
              IS_CURRENT INT NOT NULL,\
              CREATED_BY VARCHAR(100) NOT NULL,\
              CREATED_TS BIGINT NOT NULL,\
              PRIMARY KEY(ID)) ${tableoption}

imq.persist.jdbc.mysql.table.MQSES41.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (\
              BROKER_ID)
imq.persist.jdbc.mysql.table.MQSES41.index.IDX2=\
          CREATE INDEX ${index} ON ${name} (\
              BROKER_ID, IS_CURRENT)


# Destination table
imq.persist.jdbc.mysql.table.MQDST41=\
          CREATE TABLE ${name} (\
              ID VARCHAR(100) NOT NULL,\
              DESTINATION VARBINARY(2048) NOT NULL,\
              IS_LOCAL INT NOT NULL,\
              CONNECTION_ID BIGINT,\
              CONNECTED_TS BIGINT,\
              STORE_SESSION_ID BIGINT,\
              CREATED_TS BIGINT NOT NULL,\
              PRIMARY KEY(ID)) ${tableoption}

imq.persist.jdbc.mysql.table.MQDST41.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (\
              STORE_SESSION_ID)

# Interest (consumer) table
imq.persist.jdbc.mysql.table.MQCON41=\
          CREATE TABLE ${name} (\
              ID BIGINT NOT NULL,\
              CLIENT_ID VARCHAR(1024),\
              DURABLE_NAME VARCHAR(1024),\
              CONSUMER VARBINARY(2048) NOT NULL,\
              CREATED_TS BIGINT NOT NULL,\
              PRIMARY KEY(ID)) ${tableoption}

# Interest list (consumer state) table
imq.persist.jdbc.mysql.table.MQCONSTATE41=\
          CREATE TABLE ${name} (\
              MESSAGE_ID VARCHAR(100) NOT NULL,\
              CONSUMER_ID BIGINT NOT NULL,\
              STATE INT,\
              TRANSACTION_ID BIGINT,\
              CREATED_TS BIGINT NOT NULL,\
              PRIMARY KEY(MESSAGE_ID, CONSUMER_ID)) ${tableoption}

imq.persist.jdbc.mysql.table.MQCONSTATE41.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (\
              TRANSACTION_ID)

imq.persist.jdbc.mysql.table.MQCONSTATE41.index.IDX2=\
          CREATE INDEX ${index} ON ${name} (\
              MESSAGE_ID)

# Message table
imq.persist.jdbc.mysql.table.MQMSG41=\
          CREATE TABLE ${name} (\
              ID VARCHAR(100) NOT NULL,\
              MESSAGE LONGBLOB NOT NULL,\
              MESSAGE_SIZE INT,\
              STORE_SESSION_ID BIGINT NOT NULL,\
              DESTINATION_ID VARCHAR(100),\
              TRANSACTION_ID BIGINT,\
              CREATED_TS BIGINT NOT NULL,\
              PRIMARY KEY(ID)) ${tableoption}

imq.persist.jdbc.mysql.table.MQMSG41.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (\
              STORE_SESSION_ID, DESTINATION_ID)

# Property table
imq.persist.jdbc.mysql.table.MQPROP41=\
          CREATE TABLE ${name} (\
              PROPNAME VARCHAR(100) NOT NULL,\
              PROPVALUE VARBINARY(2048),\
              PRIMARY KEY(PROPNAME)) ${tableoption}

# Transaction table
imq.persist.jdbc.mysql.table.MQTXN41=\
          CREATE TABLE ${name} (\
              ID BIGINT NOT NULL,\
              TYPE INT NOT NULL,\
              STATE INT,\
              AUTO_ROLLBACK INT NOT NULL,\
              XID VARCHAR(256),\
              TXN_STATE VARBINARY(2048) NOT NULL,\
              TXN_HOME_BROKER VARBINARY(2048),\
              TXN_BROKERS VARBINARY(32672),\
              STORE_SESSION_ID BIGINT NOT NULL,\
              EXPIRED_TS BIGINT NOT NULL,\
              ACCESSED_TS BIGINT NOT NULL,\
              PRIMARY KEY(ID)) ${tableoption}

imq.persist.jdbc.mysql.table.MQTXN41.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (\
              STORE_SESSION_ID)

# JMS Bridge TM LogRecord table
imq.persist.jdbc.mysql.table.MQTMLRJMSBG41=\
          CREATE TABLE ${name} (\
              XID VARCHAR(256) NOT NULL,\
              LOG_RECORD VARBINARY(2048) NOT NULL,\
              NAME VARCHAR(100) NOT NULL,\
              BROKER_ID VARCHAR(100) NOT NULL,\
              CREATED_TS BIGINT NOT NULL,\
              UPDATED_TS BIGINT NOT NULL,\
              PRIMARY KEY(XID)) ${tableoption}
imq.persist.jdbc.mysql.table.MQTMLRJMSBG41.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (BROKER_ID)
imq.persist.jdbc.mysql.table.MQTMLRJMSBG41.index.IDX2=\
          CREATE INDEX ${index} ON ${name} (NAME)

# JMS Bridges table
imq.persist.jdbc.mysql.table.MQJMSBG41=\
          CREATE TABLE ${name} (\
              NAME VARCHAR(100) NOT NULL,\
              BROKER_ID VARCHAR(100) NOT NULL,\
              CREATED_TS BIGINT NOT NULL,\
              UPDATED_TS BIGINT NOT NULL,\
              PRIMARY KEY(NAME)) ${tableoption}

# End of properties to plug in a MySQL 5.0 database

#
# Beginning of properties to plug in a Java DB (Derby) 10.4 embedded database
#

# User name used to open database connection. Replace username.
#imq.persist.jdbc.derby.user=<username>

# Optional property to specify whether the database requires a password.
#imq.persist.jdbc.derby.needpassword=[true|false]

# Vendor specific JDBC driver.
imq.persist.jdbc.derby.driver=org.apache.derby.jdbc.EmbeddedDriver

# Vendor specific url to create a database.
imq.persist.jdbc.derby.createdburl=jdbc:derby:${imq.instanceshome}${/}${imq.instancename}${/}dbstore${/}imqdb;create=true

# Vendor specific database url to get a database connection.
imq.persist.jdbc.derby.opendburl=jdbc:derby:${imq.instanceshome}${/}${imq.instancename}${/}dbstore${/}imqdb

# Vendor specific database url to shutdown the connection.
imq.persist.jdbc.derby.closedburl=jdbc:derby:;shutdown=true

# Properties to define the tables used by the broker. Do not modify the schema.

# Version table
imq.persist.jdbc.derby.table.MQVER41=\
          CREATE TABLE ${name} (\
              STORE_VERSION INT NOT NULL,\
              LOCK_ID VARCHAR(100),\
              PRIMARY KEY(STORE_VERSION))

# Configuration change record table
imq.persist.jdbc.derby.table.MQCREC41=\
          CREATE TABLE ${name} (\
              RECORD VARCHAR(4096) FOR BIT DATA NOT NULL,\
              CREATED_TS BIGINT NOT NULL,\
              PRIMARY KEY(CREATED_TS))

# Broker table
imq.persist.jdbc.derby.table.MQBKR41=\
          CREATE TABLE ${name} (\
              ID VARCHAR(100) NOT NULL,\
              URL VARCHAR(100) NOT NULL,\
              VERSION INT NOT NULL,\
              STATE INT NOT NULL,\
              TAKEOVER_BROKER VARCHAR(100),\
              HEARTBEAT_TS BIGINT,\
              PRIMARY KEY(ID))

# Store session table
imq.persist.jdbc.derby.table.MQSES41=\
          CREATE TABLE ${name} (\
              ID BIGINT NOT NULL,\
              BROKER_ID VARCHAR(100) NOT NULL,\
              IS_CURRENT INT NOT NULL,\
              CREATED_BY VARCHAR(100) NOT NULL,\
              CREATED_TS BIGINT NOT NULL,\
              PRIMARY KEY(ID))

imq.persist.jdbc.derby.table.MQSES41.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (\
              BROKER_ID)
imq.persist.jdbc.derby.table.MQSES41.index.IDX2=\
          CREATE INDEX ${index} ON ${name} (\
              BROKER_ID, IS_CURRENT)

# Destination table
imq.persist.jdbc.derby.table.MQDST41=\
          CREATE TABLE ${name} (\
              ID VARCHAR(100) NOT NULL,\
              DESTINATION VARCHAR(2048) FOR BIT DATA NOT NULL,\
              IS_LOCAL INT NOT NULL,\
              CONNECTION_ID BIGINT,\
              CONNECTED_TS BIGINT,\
              STORE_SESSION_ID BIGINT,\
              CREATED_TS BIGINT NOT NULL,\
              PRIMARY KEY(ID))

imq.persist.jdbc.derby.table.MQDST41.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (\
              STORE_SESSION_ID)

# Interest (consumer) table
imq.persist.jdbc.derby.table.MQCON41=\
          CREATE TABLE ${name} (\
              ID BIGINT NOT NULL,\
              CLIENT_ID VARCHAR(1024),\
              DURABLE_NAME VARCHAR(1024),\
              CONSUMER VARCHAR(2048) FOR BIT DATA NOT NULL,\
              CREATED_TS BIGINT NOT NULL,\
              PRIMARY KEY(ID))

# Interest list (consumer state) table
imq.persist.jdbc.derby.table.MQCONSTATE41=\
          CREATE TABLE ${name} (\
              MESSAGE_ID VARCHAR(100) NOT NULL,\
              CONSUMER_ID BIGINT NOT NULL,\
              STATE INT,\
              TRANSACTION_ID BIGINT,\
              CREATED_TS BIGINT NOT NULL,\
              PRIMARY KEY(MESSAGE_ID, CONSUMER_ID))

imq.persist.jdbc.derby.table.MQCONSTATE41.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (\
              TRANSACTION_ID)

imq.persist.jdbc.derby.table.MQCONSTATE41.index.IDX2=\
          CREATE INDEX ${index} ON ${name} (\
              MESSAGE_ID)

# Message table
# The default maximum size for the MESSAGE column is 1 Megabytes (1m).
# If you expect to have messages that are larger than this, change the
# length according to your need before creating the tables. If the tables
# have been created already, you need to recreate them after the change.
# Note that the size includes the size of the message body, properties,
# and MQ private data.
imq.persist.jdbc.derby.table.MQMSG41=\
          CREATE TABLE ${name} (\
              ID VARCHAR(100) NOT NULL,\
              MESSAGE BLOB(1M) NOT NULL,\
              MESSAGE_SIZE INT,\
              STORE_SESSION_ID BIGINT NOT NULL,\
              DESTINATION_ID VARCHAR(100),\
              TRANSACTION_ID BIGINT,\
              CREATED_TS BIGINT NOT NULL,\
              PRIMARY KEY(ID))

imq.persist.jdbc.derby.table.MQMSG41.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (\
              STORE_SESSION_ID, DESTINATION_ID)

# Property table
imq.persist.jdbc.derby.table.MQPROP41=\
          CREATE TABLE ${name} (\
              PROPNAME VARCHAR(100) NOT NULL,\
              PROPVALUE VARCHAR(4096) FOR BIT DATA,\
              PRIMARY KEY(PROPNAME))

# Transaction table
imq.persist.jdbc.derby.table.MQTXN41=\
          CREATE TABLE ${name} (\
              ID BIGINT NOT NULL,\
              TYPE INT NOT NULL,\
              STATE INT,\
              AUTO_ROLLBACK INT NOT NULL,\
              XID VARCHAR(256),\
              TXN_STATE VARCHAR(2048) FOR BIT DATA NOT NULL,\
              TXN_HOME_BROKER VARCHAR(2048) FOR BIT DATA,\
              TXN_BROKERS VARCHAR(32672) FOR BIT DATA,\
              STORE_SESSION_ID BIGINT NOT NULL,\
              EXPIRED_TS BIGINT NOT NULL,\
              ACCESSED_TS BIGINT NOT NULL,\
              PRIMARY KEY(ID))

imq.persist.jdbc.derby.table.MQTXN41.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (\
              STORE_SESSION_ID)

# JMS Bridge TM LogRecord table
imq.persist.jdbc.derby.table.MQTMLRJMSBG41=\
          CREATE TABLE ${name} (\
              XID VARCHAR(256) NOT NULL,\
              LOG_RECORD VARCHAR(2048) FOR BIT DATA NOT NULL,\
              NAME VARCHAR(100) NOT NULL,\
              BROKER_ID VARCHAR(100) NOT NULL,\
              CREATED_TS BIGINT NOT NULL,\
              UPDATED_TS BIGINT NOT NULL,\
              PRIMARY KEY(XID))
imq.persist.jdbc.derby.table.MQTMLRJMSBG41.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (BROKER_ID)
imq.persist.jdbc.derby.table.MQTMLRJMSBG41.index.IDX2=\
          CREATE INDEX ${index} ON ${name} (NAME)

# JMS Bridges table
imq.persist.jdbc.derby.table.MQJMSBG41=\
          CREATE TABLE ${name} (\
              NAME VARCHAR(100) NOT NULL,\
              BROKER_ID VARCHAR(100) NOT NULL,\
              CREATED_TS BIGINT NOT NULL,\
              UPDATED_TS BIGINT NOT NULL,\
              PRIMARY KEY(NAME))


# End of properties to plug in a Java DB (Derby) 10.4 embedded database

#
# Beginning of properties to plug in a Java DB (Derby) Network Server 10.4
#
# To configure Java DB (Derby) database for client/server mode:
#
# Unset or clear these properties by setting the value to nothing:
# imq.persist.jdbc.derby.createdburl=
# imq.persist.jdbc.derby.closedburl=
#
# Set these properties:
# imq.persist.jdbc.derby.driver=org.apache.derby.jdbc.ClientDriver
# imq.persist.jdbc.derby.opendburl=jdbc:derby://<hostname>:<port>/${imq.instanceshome}${/}${imq.instancename}${/}dbstore${/}imqdb;create=true

# End of properties to plug in a Java DB (Derby) Network Server 10.4

#
# Beginning of properties to plug in a DB2 9.5 database
#

# User name used to open database connection. Replace username.
#imq.persist.jdbc.db2.user=<username>

# Optional property to specify whether the database requires a password.
#imq.persist.jdbc.db2.needpassword=[true|false]

# Vendor specific JDBC driver.
imq.persist.jdbc.db2.driver=com.ibm.db2.jcc.DB2Driver

# Vendor specific properties.

# Vendor specific database url to get a database connection.
# Replace hostname, port and database in imq.persist.jdbc.db2.opendburl.
#imq.persist.jdbc.db2.opendburl=jdbc:db2://<hostname>:<port>/<database>

# Properties to define the tables used by the broker. Do not modify the schema.

# Version table
imq.persist.jdbc.db2.table.MQVER41=\
          CREATE TABLE ${name} (\
              STORE_VERSION INTEGER NOT NULL,\
              LOCK_ID VARCHAR(100),\
              PRIMARY KEY(STORE_VERSION)) ${tableoption}

# Configuration change record table
imq.persist.jdbc.db2.table.MQCREC41=\
          CREATE TABLE ${name} (\
              RECORD BLOB(4K) NOT NULL,\
              CREATED_TS BIGINT NOT NULL,\
              PRIMARY KEY(CREATED_TS)) ${tableoption}

# Broker table
imq.persist.jdbc.db2.table.MQBKR41=\
          CREATE TABLE ${name} (\
              ID VARCHAR(100) NOT NULL,\
              URL VARCHAR(100) NOT NULL,\
              VERSION INTEGER NOT NULL,\
              STATE INTEGER NOT NULL,\
              TAKEOVER_BROKER VARCHAR(100),\
              HEARTBEAT_TS BIGINT,\
              PRIMARY KEY(ID)) ${tableoption}

# Store session table
imq.persist.jdbc.db2.table.MQSES41=\
          CREATE TABLE ${name} (\
              ID BIGINT NOT NULL,\
              BROKER_ID VARCHAR(100) NOT NULL,\
              IS_CURRENT INTEGER NOT NULL,\
              CREATED_BY VARCHAR(100) NOT NULL,\
              CREATED_TS BIGINT NOT NULL,\
              PRIMARY KEY(ID)) ${tableoption}

imq.persist.jdbc.db2.table.MQSES41.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (\
              BROKER_ID)
imq.persist.jdbc.db2.table.MQSES41.index.IDX2=\
          CREATE INDEX ${index} ON ${name} (\
              BROKER_ID, IS_CURRENT)

# Destination table
imq.persist.jdbc.db2.table.MQDST41=\
          CREATE TABLE ${name} (\
              ID VARCHAR(100) NOT NULL,\
              DESTINATION BLOB(2K) NOT NULL,\
              IS_LOCAL INTEGER NOT NULL,\
              CONNECTION_ID BIGINT,\
              CONNECTED_TS BIGINT,\
              STORE_SESSION_ID BIGINT,\
              CREATED_TS BIGINT NOT NULL,\
              PRIMARY KEY(ID)) ${tableoption}

imq.persist.jdbc.db2.table.MQDST41.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (\
              STORE_SESSION_ID)

# Interest (consumer) table
imq.persist.jdbc.db2.table.MQCON41=\
          CREATE TABLE ${name} (\
              ID BIGINT NOT NULL,\
              CLIENT_ID VARCHAR(1024),\
              DURABLE_NAME VARCHAR(1024),\
              CONSUMER BLOB(2K) NOT NULL,\
              CREATED_TS BIGINT NOT NULL,\
              PRIMARY KEY(ID)) ${tableoption}

# Interest list (consumer state) table
imq.persist.jdbc.db2.table.MQCONSTATE41=\
          CREATE TABLE ${name} (\
              MESSAGE_ID VARCHAR(100) NOT NULL,\
              CONSUMER_ID BIGINT NOT NULL,\
              STATE INTEGER,\
              TRANSACTION_ID BIGINT,\
              CREATED_TS BIGINT NOT NULL,\
              PRIMARY KEY(MESSAGE_ID, CONSUMER_ID)) ${tableoption}

imq.persist.jdbc.db2.table.MQCONSTATE41.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (\
              TRANSACTION_ID)

# Message table
# The default maximum size for the MESSAGE column is 10 Megabytes (10m).
# If you expect to have messages that are larger than this, change the
# length according to your need before creating the tables. If the tables
# have been created already, you need to recreate them after the change.
# Note that the size includes the size of the message body, properties,
# and MQ private data.
imq.persist.jdbc.db2.table.MQMSG41=\
          CREATE TABLE ${name} (\
              ID VARCHAR(100) NOT NULL,\
              MESSAGE BLOB(10M) NOT NULL,\
              MESSAGE_SIZE INTEGER,\
              STORE_SESSION_ID BIGINT NOT NULL,\
              DESTINATION_ID VARCHAR(100),\
              TRANSACTION_ID BIGINT,\
              CREATED_TS BIGINT NOT NULL,\
              PRIMARY KEY(ID)) ${tableoption}

imq.persist.jdbc.db2.table.MQMSG41.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (\
              STORE_SESSION_ID, DESTINATION_ID)

# Property table
imq.persist.jdbc.db2.table.MQPROP41=\
          CREATE TABLE ${name} (\
              PROPNAME VARCHAR(100) NOT NULL,\
              PROPVALUE BLOB(4K),\
              PRIMARY KEY(PROPNAME)) ${tableoption}

# Transaction table
imq.persist.jdbc.db2.table.MQTXN41=\
          CREATE TABLE ${name} (\
              ID BIGINT NOT NULL,\
              TYPE INTEGER NOT NULL,\
              STATE INTEGER,\
              AUTO_ROLLBACK INTEGER NOT NULL,\
              XID VARCHAR(256),\
              TXN_STATE BLOB(2K) NOT NULL,\
              TXN_HOME_BROKER BLOB(2K),\
              TXN_BROKERS BLOB(2K),\
              STORE_SESSION_ID BIGINT NOT NULL,\
              EXPIRED_TS BIGINT NOT NULL,\
              ACCESSED_TS BIGINT NOT NULL,\
              PRIMARY KEY(ID)) ${tableoption}

imq.persist.jdbc.db2.table.MQTXN41.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (\
              STORE_SESSION_ID)

# JMS Bridge TM LogRecord table
imq.persist.jdbc.db2.table.MQTMLRJMSBG41=\
          CREATE TABLE ${name} (\
              XID VARCHAR(256) NOT NULL,\
              LOG_RECORD BLOB(2K) NOT NULL,\
              NAME VARCHAR(100) NOT NULL,\
              BROKER_ID VARCHAR(100) NOT NULL,\
              CREATED_TS BIGINT NOT NULL,\
              UPDATED_TS BIGINT NOT NULL,\
              PRIMARY KEY(XID)) ${tableoption}
imq.persist.jdbc.db2.table.MQTMLRJMSBG41.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (BROKER_ID)
imq.persist.jdbc.db2.table.MQTMLRJMSBG41.index.IDX2=\
          CREATE INDEX ${index} ON ${name} (NAME)

# JMS Bridges table
imq.persist.jdbc.db2.table.MQJMSBG41=\
          CREATE TABLE ${name} (\
              NAME VARCHAR(100) NOT NULL,\
              BROKER_ID VARCHAR(100) NOT NULL,\
              CREATED_TS BIGINT NOT NULL,\
              UPDATED_TS BIGINT NOT NULL,\
              PRIMARY KEY(NAME))

# End of properties to plug in a DB2 9.5 database

#
# To plug in JDBC-Accessible data store that has not been defined by MQ,
# you need to set the following JDBC-related properties for the target
# database of your choice.
#
# Replace '<dbVendor>' with the name of the database or database vendor.
#imq.persist.jdbc.dbVendor=<dbVendor>
#

# Vendor specific JDBC driver.
#imq.persist.jdbc.<dbVendor>.driver=<jdbcdriver class>

# Vendor specific database url to get a database connection.
#imq.persist.jdbc.<dbVendor>.opendburl=<url to open database>

# Vendor specific url to create a database.
# This is an optional property. Should be specified if the database will
# need to be created using imqdbmgr (imqdbmgr create all).
#imq.persist.jdbc.<dbVendor>.createdburl=<url to create database>

# Vendor specific database url to shutdown the connection.
# This is an optional property. Should be specified if the database needs
# to be shutdown explicitly.
# If specified, java.sql.DriverManager.getConnection() will be called with
# the specified url at broker shutdown.
#imq.persist.jdbc.<dbVendor>.closedburl=<url to close database connection>

# User name used to open database connection.
# This is an optional property. The value can also be specified by command
# line opton for imqbroker and imqdbmgr.
#imq.persist.jdbc.<dbVendor>.user=<username>

# Specify whether the database requires a password for broker access.
# This is an optional property. It should be set to true if the database
# requires a password. Broker will prompt for the password if it is not
# provided by other means.
#imq.persist.jdbc.<dbVendor>.needpassword=[true|false]

# Properties defining the tables we use
#
# Version table
#imq.persist.jdbc.<dbVendor>.table.MQVER41=<CREATE TABLE SQL FOR VERSION TABLE>
#
# Configuration change record
#imq.persist.jdbc.<dbVendor>.table.MQCREC41=<CREATE TABLE SQL FOR CONFIGURATION CHANGE RECORD TABLE>
#
# Broker table
imq.persist.jdbc.<dbVendor>.table.MQBKR41=<CREATE TABLE SQL FOR BROKER TABLE>
#
# Store Session table
imq.persist.jdbc.<dbVendor>.table.MQSES41=<CREATE TABLE SQL FOR STORE SESSION TABLE>
#
# Destination table
#imq.persist.jdbc.<dbVendor>.table.MQDST41=<CREATE TABLE SQL FOR DESTINATION TABLE>
#
# Interest (consumer) table
#imq.persist.jdbc.<dbVendor>.table.MQCON41=<CREATE TABLE SQL FOR INTEREST TABLE>
#
# Interest list (consumer state) table
#imq.persist.jdbc.<dbVendor>.table.MQCONSTATE41=<CREATE TABLE SQL FOR INTEREST LIST TABLE>
#
# Message table
#imq.persist.jdbc.<dbVendor>.table.MQMSG41=<CREATE TABLE SQL FOR MESSAGE TABLE>
#
# Property table
#imq.persist.jdbc.<dbVendor>.table.MQPROP41=<CREATE TABLE SQL FOR PROPERTY TABLE>
#
# Transaction table
#imq.persist.jdbc.<dbVendor>.table.MQTXN41=<CREATE TABLE SQL FOR TRANSACTION TABLE>
#
# Only used by JMS bridge
#imq.persist.jdbc.<dbVendor>.table.MQTMLRJMSBG41=<CREATE TABLE SQL FOR JMS BRIDGE TRANSACTION RECORD TABLE>
#
# Only used by JMS bridge
#imq.persist.jdbc.<dbVendor>.table.MQJMSBG41=<CREATE TABLE SQL FOR JMS BRIDGES>


###############################################################################
# Shared JDBC Store Settings for Cluster Configuration Change Records (sharecc)
###############################################################################

# Set these properties as following to enable use a shared JDBC store
# for cluster config change records
###################################
# Default: false
#imq.cluster.ha=false

# Default: false
#imq.cluster.nomasterbroker=true

# Default: not set 
#imq.cluster.clusterid=<cluster-id>

# Plugged in a database, change the value of this property to the desired
# database vendor and update all appropriate JDBC related properties with
# prefix imq.cluster.sharecc.persist.jdbc.<dbVendor>
####################################################
#imq.cluster.sharecc.persist.jdbc.dbVendor=<oracle|postgresql|mysql|derby|db2>

#User name used to open database connection
#imq.cluster.sharecc.persist.jdbc.<dbVendor>.user=<username>
 
#Optional property to specify whether the database requires a password.
#imq.cluster.sharecc.persist.jdbc.<dbVendor>.needpassword=[true|false]

#
# Beginning of properties to plug in an Oracle 10g database for sharecc
#
imq.cluster.sharecc.persist.jdbc.oracle.driver=oracle.jdbc.pool.OracleConnectionPoolDataSource

#Vendor specific JDBC driver properties
#imq.cluster.sharecc.persist.jdbc.oracle.property.url=jdbc:oracle:thin:@<hostname>:<port>:<sid>
imq.cluster.sharecc.persist.jdbc.oracle.property.implicitCachingEnabled=true
imq.cluster.sharecc.persist.jdbc.oracle.property.maxStatements=25

#shared cluster configuration change record table
imq.cluster.sharecc.persist.jdbc.oracle.table.MQSHARECC50=\
          CREATE TABLE ${name} (\
              SEQ NUMBER NOT NULL,\
              UUID VARCHAR2(100) NOT NULL,\
              RECORD BLOB NOT NULL,\
              TYPE INTEGER NOT NULL,\
              UKEY VARCHAR2(2048) NOT NULL,\
              CREATED_TS NUMBER NOT NULL,\
              FLAG INTEGER,\
              LOCK_ID VARCHAR2(100),\
              PRIMARY KEY(SEQ))
imq.cluster.sharecc.persist.jdbc.oracle.table.MQSHARECC50.aftercreate=\
          CREATE SEQUENCE ${name}_seq START WITH 2 INCREMENT BY 1 ORDER NOCACHE NOCYCLE
imq.cluster.sharecc.persist.jdbc.oracle.table.MQSHARECC50.afterdrop=\
          DROP SEQUENCE ${name}_seq
imq.cluster.sharecc.persist.jdbc.oracle.table.MQSHARECC50.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (UUID)
imq.cluster.sharecc.persist.jdbc.oracle.table.MQSHARECC50.index.IDX2=\
          CREATE INDEX ${index} ON ${name} (TYPE)
imq.cluster.sharecc.persist.jdbc.oracle.table.MQSHARECC50.index.IDX3=\
          CREATE INDEX ${index} ON ${name} (UKEY)
#
# End of properties to plug in an Oracle 10g database for sharecc

#
# Beginning of properties to plug in PostgreSQL database for sharecc 
#
imq.cluster.sharecc.persist.jdbc.postgresql.driver=org.postgresql.Driver
#imq.cluster.sharecc.persist.jdbc.postgresql.opendburl=jdbc:postgresql://<hostname>:<port>/<database>

#shared cluster configuration change record table
imq.cluster.sharecc.persist.jdbc.postgresql.table.MQSHARECC50=\
          CREATE TABLE ${name} (\
              SEQ BIGSERIAL NOT NULL UNIQUE,\
              UUID VARCHAR(100) NOT NULL,\
              RECORD BYTEA NOT NULL,\
              TYPE INT NOT NULL,\
              UKEY VARCHAR(2048) NOT NULL,\
              CREATED_TS BIGINT NOT NULL,\
              FLAG INT,\
              LOCK_ID VARCHAR(100),\
              PRIMARY KEY(SEQ))
imq.cluster.sharecc.persist.jdbc.postgresql.table.MQSHARECC50.aftercreate=\
          ALTER SEQUENCE ${name}_SEQ_seq RESTART WITH 2
imq.cluster.sharecc.persist.jdbc.postgresql.table.MQSHARECC50.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (UUID)
imq.cluster.sharecc.persist.jdbc.postgresql.table.MQSHARECC50.index.IDX2=\
          CREATE INDEX ${index} ON ${name} (TYPE)
imq.cluster.sharecc.persist.jdbc.postgresql.table.MQSHARECC50.index.IDX3=\
          CREATE INDEX ${index} ON ${name} (UKEY)
#
# End of properties to plug in a PostgreSQL 8.1 database for sharecc

#
# Beginning of properties to plug in MySQL database for sharecc 
#
imq.cluster.sharecc.persist.jdbc.mysql.driver=com.mysql.jdbc.jdbc2.optional.MysqlConnectionPoolDataSource
#Vendor specific properties
#imq.cluster.sharecc.persist.jdbc.mysql.property.url=jdbc:mysql://<hostname>:<port>/<database>
imq.cluster.sharecc.persist.jdbc.mysql.property.cacheResultSetMetadata=true
imq.cluster.sharecc.persist.jdbc.mysql.property.cachePreparedStatements=true
imq.cluster.sharecc.persist.jdbc.mysql.property.preparedStatementCacheSize=25
imq.cluster.sharecc.persist.jdbc.mysql.tableoption=ENGINE=InnoDB

#shared configuration change record table
imq.cluster.sharecc.persist.jdbc.mysql.table.MQSHARECC50=\
          CREATE TABLE ${name} (\
              SEQ BIGINT NOT NULL AUTO_INCREMENT,\
              UUID VARCHAR(100) NOT NULL,\
              RECORD MEDIUMBLOB NOT NULL,\
              TYPE INT NOT NULL,\
              UKEY VARCHAR(2048) NOT NULL,\
              CREATED_TS BIGINT NOT NULL, \
              FLAG INT, \
              LOCK_ID VARCHAR(100),\
              PRIMARY KEY(SEQ)) ${tableoption} AUTO_INCREMENT = 1
imq.cluster.sharecc.persist.jdbc.mysql.table.MQSHARECC50.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (UUID)
imq.cluster.sharecc.persist.jdbc.mysql.table.MQSHARECC50.index.IDX2=\
          CREATE INDEX ${index} ON ${name} (TYPE)
imq.cluster.sharecc.persist.jdbc.mysql.table.MQSHARECC50.index.IDX3=\
          CREATE INDEX ${index} ON ${name} (UKEY)
#
# End of properties to plug in a MySQL 5.0 database for sharecc

#
# Beginning of properties to plug in Java DB (Derby) Network Server database for sharecc 
#
imq.cluster.sharecc.persist.jdbc.derby.driver=org.apache.derby.jdbc.ClientDriver
#imq.cluster.sharecc.persist.jdbc.derby.opendburl=jdbc:derby://<hostname>:<port>/<database>;create=true

#shared cluster configuration change record table
imq.cluster.sharecc.persist.jdbc.derby.table.MQSHARECC50=\
          CREATE TABLE ${name} (\
              SEQ BIGINT NOT NULL GENERATED BY DEFAULT AS IDENTITY (START WITH 2, INCREMENT BY 1),\
              UUID VARCHAR(100) NOT NULL,\
              RECORD VARCHAR(4096) FOR BIT DATA NOT NULL,\
              TYPE INT NOT NULL,\
              UKEY VARCHAR(2048) NOT NULL,\
              CREATED_TS BIGINT NOT NULL, \
              FLAG INT, \
              LOCK_ID VARCHAR(100),\
              PRIMARY KEY(SEQ))
imq.cluster.sharecc.persist.jdbc.derby.table.MQSHARECC50.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (UUID)
imq.cluster.sharecc.persist.jdbc.derby.table.MQSHARECC50.index.IDX2=\
          CREATE INDEX ${index} ON ${name} (TYPE)
imq.cluster.sharecc.persist.jdbc.derby.table.MQSHARECC50.index.IDX3=\
          CREATE INDEX ${index} ON ${name} (UKEY)
#
# End of properties to plug in a Java DB (Derby) Network Server 10.4 for sharecc

#
# Beginning of properties to plug in DB2 database for sharecc 
#
imq.cluster.sharecc.persist.jdbc.db2.driver=com.ibm.db2.jcc.DB2Driver
#imq.cluster.sharecc.persist.jdbc.db2.opendburl=jdbc:db2://<hostname>:<port>/<database>

#shared cluster configuration change record table
imq.cluster.sharecc.persist.jdbc.db2.table.MQSHARECC50=\
          CREATE TABLE ${name} (\
              SEQ BIGINT NOT NULL GENERATED BY DEFAULT AS IDENTITY (START WITH 2, INCREMENT BY 1),\
              UUID VARCHAR(100) NOT NULL,\
              RECORD BLOB(4K) NOT NULL,\
              TYPE INTEGER NOT NULL,\
              UKEY VARCHAR(2048) NOT NULL,\
              CREATED_TS BIGINT NOT NULL,\
              FLAG INTEGER,\
              LOCK_ID VARCHAR(100),\
              PRIMARY KEY(SEQ))
imq.cluster.sharecc.persist.jdbc.db2.table.MQSHARECC50.index.IDX1=\
          CREATE INDEX ${index} ON ${name} (UUID)
imq.cluster.sharecc.persist.jdbc.db2.table.MQSHARECC50.index.IDX2=\
          CREATE INDEX ${index} ON ${name} (TYPE)
imq.cluster.sharecc.persist.jdbc.db2.table.MQSHARECC50.index.IDX3=\
          CREATE INDEX ${index} ON ${name} (UKEY)
#
# End of properties to plug in a DB2 9.5 database for sharecc


##############################################################
# Security Settings
##############################################################

# Authentication Type
#####################

# You can specify two types of authentication: basic and digest.

# basic
imq.authentication.basic.user_repository=file

# digest (value of this property should not be changed from file)
imq.authentication.digest.user_repository=file

# You can specify authentication for all connection services or
# on a service-by-service basis. Individual service settings override 
# system settings.
# To specify individual service setting, use
# imq.<service_name>.authentication.type
imq.authentication.type=digest

# Authentication Timeout
########################

# timeout in seconds in waiting for client hello and response to
# authentication request on a connection
imq.authentication.client.response.timeout=180

# User Repository
#################

# You can define access to 3 types of user repositories:
# file-based, LDAP or JAAS 

# File-based (file) user repository:
imq.user_repository.file.filename=passwd

# LDAP user repository (only supported for basic authentication type)
# The following properties are an example setup (please configure)
#
#imq.user_repository.ldap.server=host:port
#imq.user_repository.ldap.principal=
#imq.user_repository.ldap.base=ou=People, dc=sun,dc=com
#imq.user_repository.ldap.uidattr=uid
#imq.user_repository.ldap.usrformat=
#imq.user_repository.ldap.usrfilter=
#imq.user_repository.ldap.grpsearch=false
#imq.user_repository.ldap.grpbase=ou=Groups, dc=sun,dc=com
#imq.user_repository.ldap.gidattr=cn
#imq.user_repository.ldap.memattr=uniquemember
#imq.user_repository.ldap.grpfilter=
#imq.user_repository.ldap.ssl.enabled=false
#imq.user_repository.ldap.ssl.socketfactory=com.sun.messaging.jmq.jmsserver.auth.ldap.TrustSSLSocketFactory
# (search in seconds)
#imq.user_repository.ldap.timeout=180
# 
# By default the property imq.user_repository.ldap.ssl.socketfactory
# is configured with a trust-all TrustManager using Sun JSSE reference
# implementation.  With this configuration, LDAP server's certificate
# (X.509-based) is automatically trusted by the broker and LDAP server
# client authentication is not supported.
#
# If this property is not specified, the Sun LDAP provider will use
# javax.net.ssl.SSLSocketFactory to attempt to create a SSL socket
# to communicate with the LDAP server.  In this case, you are responsible
# for any necessary certificate installation/setup on the broker machine
# by following javax.net package guide and Java 2 security guide.

# JAAS user repository (only supported for basic authentication type)
# These are configurable properties for JAAS user repository 
#
#imq.user_repository.jaas.name
#imq.user_repository.jaas.userPrincipalClass
#imq.user_repository.jaas.groupPrincipalClass

# Access Control
################

# Enable authorization (access control)
# You can enable access control for all connection services or
# on a service-by-service basis. Individual service settings override 
# system settings.
# To enable individual service setting, use
# imq.<service_name>.accesscontrol.enabled
imq.accesscontrol.enabled=true
imq.accesscontrol.type=file

# You can currently specify only file-based access control.

# File-based (file) access control
# imq.<service_name>.accesscontrol.file.filename
imq.accesscontrol.file.filename=accesscontrol.properties


##############################################################
# Logger Settings
##############################################################

# Log Level
###########
# Only messages >= this level will get passed on to output channels 
(LogHandlers).
# The categories used in normal operation of the broker from highest 
# level to lowest are: ERROR, WARNING, INFO. You may specify NONE to 
# turn off logging.
.level=INFO

# Output Channels (LogHandlers)
###############################

# All Output Channels (LogHandlers) write out messages based on specific
# categories. Valid categories are ALL to select all messages, NONE
# to select no message or a specific level to log that level and above 
# ERROR, WARNING, INFO.

# Specify supported and needed LogHandlers
# Supported Handles are java.util.logging.FileHandler, java.util.logging.ConsoleHandler,
# 
#Old imq.log.handlers=file,console,destination,jmx
handlers=java.util.logging.FileHandler, java.util.logging.ConsoleHandler, com.sun.messaging.jmq.jmsserver.service.DestinationLogHandler, com.sun.messaging.jmq.util.log.SysLogHandler, com.sun.messaging.jmq.jmsserver.management.agent.JMXLogHandler

# FileLogHandler settings.
# The FileLogHandler logs messages to a set of rolling files.
# The rollover criteria can be the file size (bytes) and/or
# the file age (seconds). 0 means don't rollover based on that criteria.
#java.util.logging.FileHandler.level specifies the default level for the Handler (defaults to Level.ALL). 
#java.util.logging.FileHandler.filter specifies the name of a Filter class to use (defaults to no Filter). 
#java.util.logging.FileHandler.formatter specifies the name of a Formatter class to use (defaults to java.util.logging.XMLFormatter) 
#java.util.logging.FileHandler.encoding the name of the character set encoding to use (defaults to the default platform encoding). 
#java.util.logging.FileHandler.limit specifies an approximate maximum amount to write (in bytes) to any one file. If this is zero, then there is no limit. (Defaults to no limit). 
#java.util.logging.FileHandler.count specifies how many output files to cycle through (defaults to 1). 
#java.util.logging.FileHandler.pattern specifies a pattern for generating the output file name. See below for details. (Defaults to "%h/java%u.log"). 
#java.util.logging.FileHandler.append specifies whether the FileHandler should append onto any existing files (defaults to false). 
java.util.logging.FileHandler.level=ALL
java.util.logging.FileHandler.formatter=com.sun.messaging.jmq.util.log.UniformLogFormatter
java.util.logging.FileHandler.limit=268435456
java.util.logging.FileHandler.pattern=${imq.instanceshome}${/}${imq.instancename}${/}log${/}log.txt

# Console settings.
# The console handler logs messages to an OutputStream. This can either be
# System.err (ERR) or System.out (OUT).
java.util.logging.ConsoleHandler.formatter=com.sun.messaging.jmq.util.log.UniformLogFormatter
java.util.logging.ConsoleHandler.level=WARNING

# Syslog settings.
# The syslog handler logs messages to syslog on UNIX.
imq.log.syslog.facility=LOG_DAEMON
imq.log.syslog.logpid=true
imq.log.syslog.logconsole=false
imq.log.syslog.identity=imqbrokerd_${imq.instancename}
imq.log.syslog.output=ERROR

# Destination log handler settings.
# The destination handler logs messages to a topic (mq.log.broker)
imq.log.destination.output=WARNING
imq.log.destination.timetolive=300
imq.log.destination.persist=false

# JMX log handler settings
# The jmx log handler exposes log messages as JMX notifications
imq.log.jmx.output=ALL

# Metrics settings
##################

# These settings enable metric counting in the broker and set the 
# time interval (in seconds)
# at which the broker will generate a metrics report. 0 means no report.
imq.metrics.enabled=true
imq.metrics.interval=0
imq.metrics.topic.enabled=true
imq.metrics.topic.interval=60
imq.metrics.topic.persist=false
imq.metrics.topic.timetolive=300


##############################################################
# Destination Management Settings
##############################################################

# autocreate for topics should always be true
imq.autocreate.topic=true

# autocreate for queues should default to false after EA
imq.autocreate.queue=true

# Time (in seconds) an un-used autocreated destination will 
# remain in the broker before being destroyed. (this prevents
# continually creating and destroying autocreated destinations
# which are frequently used)
#
imq.autocreate.reaptime=120


##############################################################
# Transaction Settings
##############################################################

# Control how the broker processes distributed (XA) tranactions
# at startup that were left "in-doubt", i.e. two phase commit
# transactions that were prepared but not committed.
#     true: Automatically rollback any transactions in the PREPARED state
#    false: Leave transactions in the PREPARED state alone. They will be
#           resolved via MQ or JTA administration.
# Transactions left in any other state are rolled-back at broker startup.
imq.transaction.autorollback=false

# XA transactions in states INCOMPLETE or COMPLETE will be 
# timed out after this number of seconds (0 means no timeout)
# if its creation connection is gone 
imq.transaction.detachedTimeout=0

# This sets a limit on the maximum # of messages that the producer
# can process in one transaction to prevent resource exhaustion.
# It is recommended that this value should be less than 5000.
# Default: 1000 messages
imq.transaction.producer.maxNumMsgs=1000

# This sets a limit on the maximum # of messages that the consumer
# can process in one transaction to prevent resource exhaustion.
# It is recommended that this value should be less than 1000.
# Default: 100 messages
imq.transaction.consumer.maxNumMsgs=100


##############################################################
# Miscellaneous Settings
##############################################################

# Exit code Broker uses when it is exiting due to a restart
imq.restart.code=255

# imq.ping.interval
#
# Determines how often (in seconds) to check on a quiet client
# (a client who is not sending or receiving messages) to
# make sure it is still up
#
# This prevents a "half-closed" tcp connection (where
# the network connection is gone .. but the broker received
# no notification because it wasnt trying to send or receive
# messages at the time the connection disappeared
#
# default is 2 minutes
#
# imq.ping.interval=120 
#

# imq.ping.enabled
#
# turns on/off this pinging feature. (since the ping adds additional
# overhead to quiet clients)
# 
# default is true
#
# imq.ping.enabled=true
#

# imq.cluster.url
# imq.cluster.brokerlist
# imq.cluster.masterbroker
# imq.cluster.transport

# imq.cluster.port
#
# Assigns a fixed port number for the cluster protocol.
# Default value is 0 - indicating a dynamic port. Change this
# value if you need to expose the cluster port through firewall.
#
# imq.cluster.port=8686
#

# imq.cluster.hostname
#
# Bind hostname / IP address for the cluster service.
# If this property is not set, all available IP addresses are used.
# It can be used to restrict the cluster service to a specific network
# interface on machines with multiple network interfaces. The cluster
# service cannot be bound to localhost (127.0.0.1).
#
# imq.cluster.hostname=
#

# imq.cluster.consumerFlowLimit
#
# The maximum # of messages which will be sent to a consumer
# on a remote broker w/o a resume flow 
# The actual limit used is the maximum of this value and the
# value associated w/ the destination
#
# Default value is 1000
#
# imq.cluster.consumerFlowLimit=1000
#

# High-Availability (HA) Cluster Configuration Setting

# Specify whether the broker is an HA broker.
#
# Default: false
#
# imq.cluster.ha=false
#

# Unique identifier used to identify an HA cluster.
# The value must be the same for all brokers in a given HA cluster.
#
# imq.cluster.clusterid=
#

# The host name (or IP address) for the heartbeat connection service.
#
# Default: the same host name of imq.hostname
#
# imq.cluster.heartbeat.hostname=
#

# The port number for the heartbeat connection service.
#
# Default: the same port number of the Port Mapper
#
# imq.cluster.heartbeat.port=
#

# Specify the interval at which heartbeat packets are transmitted.
#
# Default: 5 secs
#
# imq.cluster.heartbeat.interval=5
#

# Specify the number of missed heartbeat intervals after 
# which a broker is considered suspect of failure.
#
# Default: 3
#
# imq.cluster.heartbeat.threshold=3
#

# Specify the interval at which to monitor a suspect broker's state
# information to determine whether it has failed.
#
# Default: 30 secs
#
# imq.cluster.monitor.interval=30
#

# Specify the number of elapsed monitor intervals after
# which a suspect broker is considered to have failed.
#
# Default: 3
#
# imq.cluster.monitor.threshold=3
#

# Force read packets to always use heap buffers
imq.packet.read.override=heap

# Diagnostic classes
# To control for a particular class:
# imq.diag.<full-class-nam>=true
imq.diag.all=true


##############################################################
# Memory Management
##############################################################
#
# memory levels (in order)
#
imq.memory.levels=green,yellow,orange,red

# Overhead: a buffer value which ajusts the
# maximum memory available on the broker 
# before calculating thresholds
# 
imq.memory.overhead=10240

# % of memory to start the memory
# level at
imq.green.threshold=0
imq.yellow.threshold=80
imq.orange.threshold=90
imq.red.threshold=98

# Per connection message flow count at the various levels
imq.green.count=5000
imq.yellow.count=500
imq.orange.count=50
imq.red.count=0

# Low Level Memory Management control properties:
#
#   quickCheck - perform a quick check of memory each time
#                each time a new message is read in If it
#                is larger than a specific size
#                Default is false (no check)
#
# imq.memory_management.quickCheck=false
#
#   quickCheckSize - size in bytes. Any messaeg larger than this
#                value triggers a "quick memory check" IF
#                quickCheck is active
#                Default is 10k (10240 bytes)
#
# imq.memory_management.quickCheckSize=10240
#
#   explicitCheck - perform a more explicity check of memory
#                each time a new message is read in
#                Default is false (no check)
#
#
# imq.memory_management.explicitCheck=false
#
#   <level>.seconds: - how often (in seconds) the system should check
#                  memory to determine if it has moved into or out of a
#                  memory level. Defaults vary based on the current level.
#                  Green,Yellow have defaults of 5 seconds
#                  Orange has a default of 1 second
#                  Red has a default of 10 second (this slows down
#                      the system from moving back into a higher state)
#
# imq.green.seconds=5
# imq.yellow.seconds=5
# imq.orange.seconds=1
# imq.red.seconds=10
#

# destination based properties
#
#  Set destination properties used by autocreated destinations
#
#   imq.autocreate.topic.consumerFlowLimit=1000
#   imq.autocreate.queue.consumerFlowLimit=100
#   imq.autocreate.queue.maxNumActiveConsumers=-1
#   imq.autocreate.queue.maxNumBackupConsumers=0
#   imq.autocreate.queue.localDeliveryPreferred=false
#   imq.autocreate.destination.isLocalOnly=false
#   imq.autocreate.destination.maxNumMsgs=100000
#   imq.autocreate.destination.maxTotalMsgBytes=10m
#   imq.autocreate.destination.maxNumProducers=100
#   imq.autocreate.destination.maxBytesPerMsg=10k
#   imq.autocreate.destination.limitBehavior=REJECT_NEWEST
#   imq.autocreate.destination.useDMQ=true

# maximum # of messages a producer should send to the broker
# in a batch
#  imq.producer.maxBatch=1000

#
# do not store the message body when a message is
# placed in the DMQ
imq.destination.DMQ.truncateBody=false

# 
# log information as dead messages are placed
# in the DMQ or removed from the system
#                   
imq.destination.logDeadMsgs=false

#
# Fix for CR 6196233
# fix is controlled via the property
#
imq.fix.JMSMessageID=true

